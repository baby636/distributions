name: CI

on:
  push:
# TODO: restore after testing
#    branches:
#      - master
#  pull_request:
#    branches:
#      - master

env:
 # TODO: remove after testing
  DIST_ROOT: '/ipfs/QmX6J3hVtMF9Y73CKcyLHfgviEfXGFFQABWPXsD17EsBhg' # dist.ipfs.io without ipfs-update@v1.7.1

jobs:
  build:
    runs-on: "ubuntu-latest"
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '14'
      - name: Install ipfs and deps
        run: |
          sudo snap install ipfs jq
          ipfs init --profile server
      - name: Wait for ipfs daemon
        run: ipfs daemon & npx wait-port http://127.0.0.1:8080/api/v0/version
      - name: Connect to ipfs cluster
        run: ipfs swarm connect /dnsaddr/cluster.ipfs.io
      - name: Build any new ./releases
        run: ./dockerized make all_dists
      - name: Inspect git status and contents of ./releases
        run: git status && ls -Rhl ./releases
      - name: Temporarily save ./releases artifacts
        uses: actions/upload-artifact@v2
        with:
          name: releases-unsigned-diff
          path: releases
          retention-days: 1

  lint:
    runs-on: "ubuntu-latest"
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '14'
      - run: npm ci --no-audit --progress=false
      - run: npm run lint

  sign-macos:
    runs-on: "macos-latest"
    needs: build
    steps:
      - uses: actions/checkout@v2
      - name: Retrieve unsigned artifacts
        uses: actions/download-artifact@v2
        with:
          name: releases-unsigned-diff
          path: releases
      - name: List ./releases before
        run: ls -Rhl ./releases
      - name: Install gon via HomeBrew for code signing and app notarization
        run: |
          brew tap mitchellh/gon
          brew install ipfs coreutils gawk gnu-sed jq mitchellh/gon/gon
          ipfs init --profile server # needed for calculating NEW_CID later
      - name: Import Keychain Certs
        uses: apple-actions/import-codesign-certs@253ddeeac23f2bdad1646faac5c8c2832e800071 # v1@2020-02-03
        with:
          p12-file-base64: ${{ secrets.APPLE_CERTS_P12 }}
          p12-password: ${{ secrets.APPLE_CERTS_PASS }}
      - name: Verify identity used for signing
        run: security find-identity -v
      - name: Unpack any new darwin arm64 and amd64 binaries to ./tmp
        run: |
          # ./releases/{DIST_NAME}/{DIST_VERSION}/*_darwin-${arch}.tar.gz -> ./tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-unsigned/
          for NEW_DIR in ./releases/*/v*; do
            (! test -d "$NEW_DIR") && continue
            DIST_VERSION=$(basename "$NEW_DIR")
            DIST_NAME=$(basename $(dirname "$NEW_DIR"))
            for arch in "amd64" "arm64"; do
              mkdir -p "./tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-unsigned"
              tar -zxvf "./releases/${DIST_NAME}/${DIST_VERSION}/${DIST_NAME}_${DIST_VERSION}_darwin-${arch}.tar.gz" -C "./tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-unsigned/"
            done
          done
          ls -Rhl ./tmp
      - name: Sign and notarize the mac binaries
        env:
          AC_USERNAME: ${{ secrets.APPLE_AC_USERNAME }} # implicitly read from env by gon
          AC_PASSWORD: ${{ secrets.APPLE_AC_PASSWORD }}
        run: |
          # Find and sign executables in ./tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-unsigned/
          for NEW_DIR in ./releases/*/v*; do
            (! test -d "$NEW_DIR") && continue
            DIST_VERSION=$(basename "$NEW_DIR")
            DIST_NAME=$(basename $(dirname "$NEW_DIR"))
            for arch in "amd64" "arm64"; do
              EXECUTABLES=$(jq -nc '$ARGS.positional' --args $(find "./tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-unsigned/" -perm +111 -type f -print))
              echo "{
                  \"source\" : $EXECUTABLES,
                  \"bundle_id\" : \"io.ipfs.dist.${DIST_NAME}\",
                  \"apple_id\": {
                    \"password\":  \"@env:AC_PASSWORD\"
                  },
                  \"sign\" :{
                    \"application_identity\" : \"Developer ID Application: Protocol Labs, Inc. (7Y229E2YRL)\"
                  },
                  \"zip\" :{
                      \"output_path\" : \"./tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-signed.zip\"
                  }
              }" | tee | jq > "./tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-gon.json"
              gon -log-level=info -log-json "./tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-gon.json"
            done
          done
      - name: Temporarily save ./tmp
        uses: actions/upload-artifact@v2
        with:
          name: tmp
          path: ./tmp/
          retention-days: 1
      - name: Update changed binaries in ./releases
        run: |
          for NEW_DIR in ./releases/*/v*; do
            (! test -d "$NEW_DIR") && continue
            DIST_VERSION=$(basename "$NEW_DIR")
            DIST_NAME=$(basename $(dirname "$NEW_DIR"))
            for arch in "amd64" "arm64"; do
              echo "-> Starting the update of darwin_${arch}.tar.gz for name='${DIST_NAME}' and version='${DIST_VERSION}'"
              # unzip signed binaries to a directory matching .tar.gz structure
              cd "${{ github.workspace }}"
              mkdir -p "./tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-signed/${DIST_NAME}"
              cd "./tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-signed/${DIST_NAME}/"
              echo "-> Unpacking gon .zip for ${arch}"
              unzip "${{ github.workspace }}/tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-signed.zip"
              echo "-> Unpacked contents"
              ls -Rhl "${{ github.workspace }}/tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-signed/"
              # replace .tar.gz with one that has the same structure, but signed binaries
              PKG_NAME="${DIST_NAME}_${DIST_VERSION}_darwin-${arch}.tar.gz"
              PKG_ROOT="${{ github.workspace }}/releases/${DIST_NAME}/${DIST_VERSION}"
              PKG_PATH="${PKG_ROOT}/${PKG_NAME}"
              DIST_JSON="${PKG_ROOT}/dist.json"
              # read old hashes
              OLD_CID=$(cat "${PKG_PATH}.cid")
              OLD_SHA512=$(gawk '{ print $1; }' < "${PKG_PATH}.sha512")
              echo "-> Found old $PKG_NAME"
              echo "   old CID:    $OLD_CID"
              echo "   old SHA512: $OLD_SHA512"
              echo "-> Updating $PKG_NAME"
              rm "$PKG_PATH"
              tar -czvf "${{ github.workspace }}/releases/${DIST_NAME}/${DIST_VERSION}/$PKG_NAME" -C "${{ github.workspace }}/tmp/${DIST_NAME}_${DIST_VERSION}_${arch}-signed/" "${DIST_NAME}"
              # calculate new hashes
              NEW_CID=$(ipfs add -Qn "$PKG_PATH")
              NEW_SHA512_LINE=$(gsha512sum "$PKG_PATH")
              NEW_SHA512=$(echo "$NEW_SHA512_LINE" | gawk '{ print $1; }')
              echo "-> New $PKG_NAME"
              echo "   new CID:    $NEW_CID"
              echo "   new SHA512: $NEW_SHA512"
              # update metadata to use new hashes
              echo "$NEW_CID" > "${PKG_PATH}.cid"
              echo "$NEW_SHA512_LINE" > "${PKG_PATH}.sha512"
              gsed -i "s/${OLD_CID}/${NEW_CID}/g; s/${OLD_SHA512}/${NEW_SHA512}/g" "${PKG_ROOT}/dist.json"
              echo "-> Completed the update of ${arch}.tar.gz for ${DIST_NAME} ${DIST_VERSION}"
            done
          done
      - name: List ./releases after
        run: ls -Rhl ./releases
      - name: Temporarily save notarized artifacts
        uses: actions/upload-artifact@v2
        with:
          name: releases-signed-macos-diff
          path: releases
          retention-days: 1

  persist:
    runs-on: "ubuntu-latest"
    needs: sign-macos
    steps:
      - uses: actions/checkout@v2
      - name: Retrieve signed artifacts
        uses: actions/download-artifact@v2
        with:
          name: releases-signed-macos-diff
          path: releases
      - name: List ./releases
        run: ls -Rhl ./releases
      - uses: actions/setup-node@v2
        with:
          node-version: '14'
      - name: Install ipfs and deps
        run: |
          sudo snap install ipfs jq
          ipfs init --profile server
          # DNS over HTTPS to avoid random Github Action failures like
          # Error: lookup _dnsaddr.ipfs-websites.collab.ipfscluster.io on 127.0.0.53:53: dial udp 127.0.0.53:53: i/o timeout
          ipfs config --json DNS.Resolvers '{ ".": "https://cloudflare-dns.com/dns-query" }'
      - name: Wait for ipfs daemon
        run: ipfs daemon & npx wait-port http://127.0.0.1:8080/api/v0/version
      - name: Connect to cluster.ipfs.io
        run: ipfs swarm connect /dnsaddr/cluster.ipfs.io
      - run: make publish
      - run: git status
      - name: Read CID of updated DAG
        id: cid-reader
        run: echo "::set-output name=CID::$(tail -1 ./versions)"
      # pin new root to cluster + update PR status with preview link
      - name: Connect to ipfs-websites.collab.ipfscluster.io
        run: ipfs swarm connect /dnsaddr/ipfs-websites.collab.ipfscluster.io
      - uses: ipfs-shipyard/ipfs-github-action@bda86e6563a66edcea22a0b0d20db6f19a2b5899 # https://github.com/ipfs-shipyard/ipfs-github-action/pull/7
        id: ipfs
        with:
          path_to_add: /ipfs/${{ steps.cid-reader.outputs.CID }}
          cluster_host: /dnsaddr/ipfs-websites.collab.ipfscluster.io
          cluster_user: ${{ secrets.CLUSTER_USER }}
          cluster_password: ${{ secrets.CLUSTER_PASSWORD }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - run: echo ${{ steps.ipfs.outputs.url }}
      - run: echo ${{ github.ref }}
